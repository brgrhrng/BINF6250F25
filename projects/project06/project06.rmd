---
title: "Project 06: Hierarchical Clustering"
author: "Your Name"
date: "`r format(Sys.time(), '%Y%m%d')`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library('reticulate')
```

```{r, install_textdistance}

# reticulate::conda_create("BINF6250-pr6", packages = "python=3.11.13")

reticulate::conda_install(
  envname = "BINF6250-pr6", 
  packages=c("textdistance"),
  channel=c("conda-forge"), 
  conda="auto"
)
```
```{r, activate_environment}

reticulate::use_condaenv("BINF6250-pr6")
```
---

## Learning Objectives

1. Implement a distance-based phylogeny neighbor joining algorithm
1. Understanding of hierarchical clustering
1. Manipulation of arrays and lists in Python

---

## Imports
You will need to install a package called `ete3` for this project. You can do this by the command `conda install ete3`.

```{python}
from typing import List, Tuple, Dict
import numpy as np
# import ete3
import textdistance as td
```

---

## Background

Today we will implement a distance-based phylogenetic tree construction method using the Neighbor-Joining (NJ) algorithm and Smith-Waterman local alignment scores. Unlike UPGMA (Unweighted Pair Group Method using Arithmetic averages), NJ produces unrooted trees and does not assume a constant evolutionary rate across lineages, making it more biologically realistic for analyzing sequence relationships.

We will use HIV-1 reverse transcriptase sequences to construct our phylogenetic tree. The Smith-Waterman algorithm will be used to generate pairwise local alignment scores, which will then be converted into distances for tree construction. This approach is particularly suitable for HIV sequence analysis as it:
1. Handles sequence variations effectively through local alignment
2. Accounts for potential rate heterogeneity across different viral strains
3. Does not assume a molecular clock

The ultimate output will be an unrooted phylogenetic tree representing the evolutionary relationships between the HIV-1 sequences, visualized using the ete3 library. This method provides insights into viral diversity and evolutionary patterns while avoiding the assumptions of simpler hierarchical clustering approaches.

The key innovations of this implementation are:
- Use of Smith-Waterman for sensitive local alignment scoring
- Implementation of Neighbor-Joining for unrooted tree construction
- More biologically realistic evolutionary model

## Neighbor-Joining Algorithm

**Input**: Distance matrix $D$ for $n$ sequences

**Initialization**:
- Let $n$ be the number of sequences
- Assign each sequence $i$ to its own leaf node
- Initialize tree $T$ with leaf nodes

**Iteration**:
While $n > 2$:
1. Calculate Q-matrix where:
   $Q(i,j) = (n-2)d(i,j) - \sum_{k=1}^n d(i,k) - \sum_{k=1}^n d(j,k)$

2. Find pair $(i,j)$ with minimum $Q(i,j)$

3. Calculate branch lengths:
   $d_i = \frac{d(i,j) + (r_i - r_j)/(n-2)}{2}$
   $d_j = d(i,j) - d_i$
   where $r_i = \sum_{k=1}^n d(i,k)$

4. Create new node $k$
   - Add branches from $k$ to $i$ and $j$ with lengths $d_i$ and $d_j$

5. Update distances to remaining nodes $x$:
   $d(k,x) = \frac{d(i,x) + d(j,x) - d(i,j)}{2}$

6. Remove nodes $i$ and $j$
7. Add node $k$ to active nodes
8. $n = n - 1$

**Termination**:
When $n = 2$ with remaining nodes $i$ and $j$:
- Add final branch between $i$ and $j$ with length $d(i,j)$
- Return unrooted tree $T$

---

## Distance metrics for comparing sequences

### Smith-Waterman
This was previously implemented. Feel free to import if you know how...or Copy & Paste.


```{python}
def extract_acc_id(header):
  """ Extracts an ID from a header string formatted as follows:
    
    >gi|24209956|gb|AAN41470.1| reverse transcriptase, partial [HIV 1]
    
    id: 24209956
  """
  header = header.strip().strip(">")
  fields = header.split("|")
  
  # We assume the id is the pipe-separated field following gi
  id_i = fields.index("gi") + 1
  
  return fields[id_i]


def read_fasta(filename: str): # -> Dict[str, str]:
    """Reads sequences from FASTA file.

    Args:
        filename (str): Path to FASTA file containing HIV RT sequences

    Returns:
        Dict[str, str]: Dictionary mapping sequence IDs to sequences

    Examples:
        >>> seqs = read_fasta("lafayette_SARS_RT.fasta")
        >>> len(seqs) > 0
        True
    """
    
    seq_dict = {}
    
    seq_id = None
    seq = ""
    
    with open(filename) as file:
      for line in file:
        line = line.strip()
        if line[0] == ">": # Header line
          # Save previous sequence to dict
          if seq_id:
            seq_dict[seq_id] = seq
          
          # Update current id and start building a new sequence
          seq_id = extract_acc_id(line)
          seq = ""
        else: # Data line
          seq += line
          
      # Save the final sequence in file to dict
      seq_dict[seq_id] = seq
      
      return seq_dict
```


```{python}

seqs = read_fasta("lafayette_SARS_RT.fasta")
print(seqs)

```


```{python}
def build_distance_matrix(sequences: Dict[str, str]) -> Tuple[np.ndarray, List[str]]:
    """Builds distance matrix using Smith-Waterman scores.

    Args:
        sequences (Dict[str, str]): Dictionary of HIV RT sequences

    Returns:
        Tuple[np.ndarray, List[str]]: Distance matrix and list of sequence IDs

    Examples:
        >>> seqs = read_fasta("lafayette_SARS_RT.fasta")
        >>> mat, ids = build_distance_matrix(seqs)
        >>> mat[0:3, 0:3]  # Show 3x3 slice of distance matrix
        array([[0.000, 0.004, 0.012],
              [0.004, 0.000, 0.012],
              [0.012, 0.012, 0.000]])
        >>> len(ids)  # Number of sequences
        19
    """
    
    # Establish list for sequence IDs by using .keys() and converting that to list
    seq_ids = list(sequences.keys())
    
    print()
    # Establish empty matrix of len(sequences.keys()) x len(sequences.keys())
    n = len(seq_ids)
    dist_mat = np.empty(shape=(n,n), dtype = float)

    # Loop through each sequence ID, filling out the matrix at i,j and j,i because they will be the same score
    for i, acc1 in enumerate(seq_ids):
      for j, acc2 in enumerate(seq_ids):
        # In the case that the sequences do not match in length, take the longer one.
        total_len = max((len(sequences[acc1]), len(sequences[acc2])))
        # Distance (differences) is calculated by subtracting the smith waterman score from the total length of the longest sequence.
        dist_mat[i,j] =  total_len - smith_waterman(sequences[acc1], sequences[acc2]) 
        dist_mat[j,i] = dist_mat[i,j]
        # No need to continue past the zeros.
        if i == j:
          break
    return (dist_mat, seq_ids)
```

```{python}
sequences = {"1234": "ASDF", "2345": "ASDG", "3456": "ADDF", "4567": "AAAA"}
dis_mat, seq_ids = build_distance_matrix(sequences)
print(dis_mat)
print(seq_ids)
```

```{python}
def get_min_distance(matrix):
    ''' Function to find the smallest value off-daigonal in the distance
    matrix provided. This is used in the UPGMA algorithm.
    
    Args: 
        matrix (2D numpy array): a distance matrix

    Returns:
        min (float): The smallest distance in the matrix
        pos (tuple): The x and y position of the smallest distance
    
    '''
    
    minimum = np.min(matrix)
    # Argmin finds the position of the minimum and returns a number representing that position.
    # Unravel index unpacks that position into a tuple.
    min_pos = np.unravel_index(np.argmin(matrix), matrix.shape)
    return minimum, min_pos
    
```


:

```{python}
def neighbor_joining(
    distance_matrix: np.ndarray,
    labels: List[str],
    newick_str = ""
) -> str:
    """Implements Neighbor-Joining algorithm for phylogenetic tree construction.

    Args:
        distance_matrix (np.ndarray): Distance matrix from Smith-Waterman scores
        labels (List[str]): Sequence identifiers

    Returns:
        str: Newick format tree string

    Examples:
        >>> seqs = read_fasta("lafayette_SARS_RT.fasta")
        >>> mat, ids = build_distance_matrix(seqs)
        >>> tree = neighbor_joining(mat, ids)
        >>> tree.startswith("((DM1:0.002,DM2:0.002)")  # Start of Newick string
        True
        >>> tree.count(",")  # Number of separators in tree
        18
    """
    
    n = len(labels)
    
    # IF distance_matrix is 2x2, return the final tree.
    if n==2:
      length_from_root = distance_matrix[0,1]
      return f"({newick_str}:{length_from_root},{labels[1]}:{length_from_root})"
    
    # From distance matrix, calculate the distance of each sequence to all other sequences.
    total_distances = distance_matrix.sum(axis = 0)
    # We divide by n-2 to simplify the limb length calculation later down the line.
    total_distances = [val/(n-2) for val in total_distances]
    
    print("-------------------------------------")
    print("DISTANCE MATRIX:\n", distance_matrix)
    print("DISTANCE TOTALS:\n", total_distances)
    
    # Create Q-matrix, or "net divergence" matrix
    q_matrix = np.empty(shape=(n,n), dtype = float)
    for row_index, row in enumerate(distance_matrix):
      for col_index, dist_val in enumerate(row):
        if row_index == col_index:
          q_matrix[row_index,col_index] = 0
          break
        else:
          q_matrix[row_index,col_index] = dist_val - total_distances[row_index] - total_distances[col_index]
          q_matrix[col_index,row_index] = q_matrix[row_index,col_index] # mirror values across diagonal
        
    print("Q MATRIX:\n", q_matrix)
    
    # Find the lowest net divergence value and get the two taxa it corresponds to.
    min_val, min_pos = get_min_distance(q_matrix)
    
    # Testing different merge scenario:
    #if n == 4:
      #min_pos = (3,2)
    #print(min_pos)
    
    # The position of the minimum value represents a new node (common ancestor) between the two taxa.
    taxa1, taxa2 = min_pos
    
    # Get the divergence value for each taxa.
    total_dist1 = total_distances[taxa1]
    total_dist2 = total_distances[taxa2]
    
    # Calculate limb lengths of each taxa to the new node, adjusted by the difference between the two divergences.
    limb_length1 = (distance_matrix[taxa1,taxa2] + total_dist1 - total_dist2) / 2
    limb_length2 = (distance_matrix[taxa1,taxa2] + total_dist2 - total_dist1) / 2
    
    #print(limb_length1,limb_length2)
    
    # Create new distance matrix with distances of remaining taxa to new node.
    
    id_1 = labels[taxa1]
    id_2 = labels[taxa2]
    
    # Create a new merged taxa.
    merged_vals = np.empty(n)
    
    for row_i, row in enumerate(distance_matrix):
      # Calculating new distances of remaining taxa to merged taxa.
      merged_val = (row[taxa1] + row[taxa2] - distance_matrix[taxa1,taxa2]) / 2
      merged_vals[row_i] = merged_val
      
    #print("merged_vals:", merged_vals)
    
    # Replace taxa1 row and column with merged taxa.
    distance_matrix[:, taxa1] = merged_vals
    distance_matrix[taxa1] = merged_vals
    
    labels[taxa1] = f"{id_2},{id_1}" #
    labels.pop(taxa2)
    
    #print(labels)
    
    # Remove taxa2 row and column.
    distance_matrix = np.delete(distance_matrix, (taxa2), axis=0)
    distance_matrix = np.delete(distance_matrix, (taxa2), axis=1)

    #print(distance_matrix)
    
    # At very beginning of neighbor joining.
    if not newick_str:
      newick = f"({id_2}:{limb_length2},{id_1}:{limb_length1})"
      #print(newick)
      return neighbor_joining(distance_matrix, labels, newick)
    # Neither new taxa are the merged taxa.
    if id_1[0] not in newick_str and id_2[0] not in newick_str:
      unused_newick = newick_str
      new_newick = f"({id_2}:{limb_length2},{id_1}:{limb_length1})"
      newick = f"({unused_newick},{new_newick})"
      #print(newick)
      return neighbor_joining(distance_matrix, labels, newick)
    # Attach unmerged taxa to merged taxa.  
    newick = f"({id_2}:{limb_length2},{newick_str}:{limb_length1})"
    
    #newick = f"({lbl_i}:{limb_lengthi}{newick_str},{lbl_j}:{limb_lengthj})"
    #newick = f"({lbl_i}:{limb_lengthi},{lbl_j}:{limb_lengthj})"
    
    #print(newick)
    
    
    return neighbor_joining(distance_matrix, labels, newick)
```

```{python}
# test distance matrix
dm = np.array([
  [0,17,21,27],
  [17,0,12,18],
  [21,12,0,14],
  [27,18,14,0]])
ids = ["A","B","C","D"]
tree = neighbor_joining(dm,labels=ids)
print("FINAL TREE:", tree)
```

(AB)(CD)

```{python}
sequences = {"1234": "ASDF", "2345": "ASDG", "3456": "ADDF", "4567": "AAAA"}
dis_mat, seq_ids = build_distance_matrix(sequences)
tree = neighbor_joining(dis_mat, seq_ids)
```


```{python}
def plot_tree(newick_tree: str) -> None:
    """Plots phylogenetic tree using ete3.

    Args:
        newick_tree (str): Tree in Newick format
    """
    tree = ete3.Tree(newick_tree)
    ts = ete3.TreeStyle()
    ts.show_leaf_name = True
    ts.mode = "c"  # circular style
    return tree.render("%%inline", tree_style=ts)
```

```{python}
if __name__ == "__main__":
    # Read HIV RT sequences
    sequences = read_fasta("lafayette_SARS_RT.fasta")
    
    # Build distance matrix using Smith-Waterman
    dist_matrix, seq_ids = build_distance_matrix(sequences)
    
    # Generate unrooted tree using Neighbor-Joining
    tree = neighbor_joining(dist_matrix, seq_ids)
    
    # Plot tree
    plot_tree(tree)
```

