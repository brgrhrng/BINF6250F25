---
title: "Project 06: Hierarchical Clustering"
author: "Your Name"
date: "`r format(Sys.time(), '%Y%m%d')`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library('reticulate')
```

---

## Learning Objectives

1. Implement a distance-based phylogeny neighbor joining algorithm
1. Understanding of hierarchical clustering
1. Manipulation of arrays and lists in Python

---

## Imports
You will need to install a package called `ete3` for this project. You can do this by the command `conda install ete3`.

```{python}
from typing import List, Tuple, Dict
import numpy as np
# import ete3
import textdistance as td
```

---

## Background

Today we will implement a distance-based phylogenetic tree construction method using the Neighbor-Joining (NJ) algorithm and Smith-Waterman local alignment scores. Unlike UPGMA (Unweighted Pair Group Method using Arithmetic averages), NJ produces unrooted trees and does not assume a constant evolutionary rate across lineages, making it more biologically realistic for analyzing sequence relationships.

We will use HIV-1 reverse transcriptase sequences to construct our phylogenetic tree. The Smith-Waterman algorithm will be used to generate pairwise local alignment scores, which will then be converted into distances for tree construction. This approach is particularly suitable for HIV sequence analysis as it:
1. Handles sequence variations effectively through local alignment
2. Accounts for potential rate heterogeneity across different viral strains
3. Does not assume a molecular clock

The ultimate output will be an unrooted phylogenetic tree representing the evolutionary relationships between the HIV-1 sequences, visualized using the ete3 library. This method provides insights into viral diversity and evolutionary patterns while avoiding the assumptions of simpler hierarchical clustering approaches.

The key innovations of this implementation are:
- Use of Smith-Waterman for sensitive local alignment scoring
- Implementation of Neighbor-Joining for unrooted tree construction
- More biologically realistic evolutionary model

## Neighbor-Joining Algorithm

**Input**: Distance matrix $D$ for $n$ sequences

**Initialization**:
- Let $n$ be the number of sequences
- Assign each sequence $i$ to its own leaf node
- Initialize tree $T$ with leaf nodes

**Iteration**:
While $n > 2$:
1. Calculate Q-matrix where:
   $Q(i,j) = (n-2)d(i,j) - \sum_{k=1}^n d(i,k) - \sum_{k=1}^n d(j,k)$

2. Find pair $(i,j)$ with minimum $Q(i,j)$

3. Calculate branch lengths:
   $d_i = \frac{d(i,j) + (r_i - r_j)/(n-2)}{2}$
   $d_j = d(i,j) - d_i$
   where $r_i = \sum_{k=1}^n d(i,k)$

4. Create new node $k$
   - Add branches from $k$ to $i$ and $j$ with lengths $d_i$ and $d_j$

5. Update distances to remaining nodes $x$:
   $d(k,x) = \frac{d(i,x) + d(j,x) - d(i,j)}{2}$

6. Remove nodes $i$ and $j$
7. Add node $k$ to active nodes
8. $n = n - 1$

**Termination**:
When $n = 2$ with remaining nodes $i$ and $j$:
- Add final branch between $i$ and $j$ with length $d(i,j)$
- Return unrooted tree $T$

---

## Distance metrics for comparing sequences

### Smith-Waterman
This was previously implemented. Feel free to import if you know how...or Copy & Paste.


```{python}
def extract_acc_id(header):
  """ Extracts an ID from a header string formatted as follows:
    
    >gi|24209956|gb|AAN41470.1| reverse transcriptase, partial [HIV 1]
    
    id: 24209956
  """
  header = header.strip().strip(">")
  fields = header.split("|")
  
  # We assume the id is the pipe-separated field following gi
  id_i = fields.index("gi") + 1
  
  return fields[id_i]


def read_fasta(filename: str): # -> Dict[str, str]:
    """Reads sequences from FASTA file.

    Args:
        filename (str): Path to FASTA file containing HIV RT sequences

    Returns:
        Dict[str, str]: Dictionary mapping sequence IDs to sequences

    Examples:
        >>> seqs = read_fasta("lafayette_SARS_RT.fasta")
        >>> len(seqs) > 0
        True
    """
    
    seq_dict = {}
    
    seq_id = None
    seq = ""
    
    with open(filename) as file:
      for line in file:
        line = line.strip()
        if line[0] == ">": # Header line
          # Save previous sequence to dict
          if seq_id:
            seq_dict[seq_id] = seq
          
          # Update current id and start building a new sequence
          seq_id = extract_acc_id(line)
          seq = ""
        else: # Data line
          seq += line
          
      # Save the final sequence in file to dict
      seq_dict[seq_id] = seq
      
      return seq_dict
```


```{python}

seqs = read_fasta("lafayette_SARS_RT.fasta")
print(seqs)

```




```{python}
def cal_score(matrix, seq1, seq2, i, j, match, mismatch, gap):
    '''Calculate score for position (i,j) in scoring matrix, also record move to trace back
    
    Args:
        matrix (numpy array): scoring matrix
        seq1 (str): sequence 1
        seq2 (str): sequence 2
        i (int): current row number
        j (int): current column number
        
    Returns:
        score in position (i,j)    
        move to trace back: 0-END, 1-DIAG, 2-UP, 3-LEFT
        
    Pseudocode:
        Calculate scores based on upper-left, up, and left neighbors:
            diag_score = upper-left + (match or mismatch)
            up_score = up + gap
            left_score = left + gap
        score = max(0, diag_score, up_score, left_score)
        traceback = maximum direction or end
        
    '''
    # Determine scores at prev positions
    diag_node = matrix[i-1, j-1]
    up_node = matrix[i-1, j]
    left_node = matrix[i, j-1]
    
    # calculate diag_score by comparing respective nucleotides
    # Needs - 1 because we start i and j at 1
    if seq1[i-1] == seq2[j-1]:
      diag_score = diag_node + match
    else:
      diag_score = diag_node + mismatch
      
    up_score = up_node + gap
    left_score = left_node + gap
    
    score = max(0, diag_score, up_score, left_score)

    return score 
    
```

```{python}
def smith_waterman(
    sequence1: str,
    sequence2: str,
    match_score: float = 2.0,
    mismatch_penalty: float = -1.0,
    gap_penalty: float = -1.0
) -> float:
    """Implements Smith-Waterman local alignment algorithm.

    Args:
        sequence1 (str): First HIV RT sequence
        sequence2 (str): Second HIV RT sequence
        match_score (float): Score for matching characters
        mismatch_penalty (float): Penalty for mismatched characters
        gap_penalty (float): Penalty for gaps

    Returns:
        float: Normalized similarity score between sequences

    Examples:
        >>> seq1 = "ACGT"
        >>> seq2 = "ACGT"
        >>> smith_waterman(seq1, seq2)
        1.0
    """
    
    #implement smith-waterman algorithm from last project, will need cal_score
    #unsure whether score is the max or if we need to do some more math since it asks for "normalized similarity score"
    
    m = len(sequence1) + 1  # number of rows
    n = len(sequence2) + 1  # number of columns
    score_matrix = np.zeros((m, n))

    for i in range(1, m):
      for j in range(1, n):
        score_matrix[i, j] = cal_score(score_matrix, sequence1, sequence2, i, j, match_score, mismatch_penalty, gap_penalty)
        
    score = np.max(score_matrix)/match_score

    return score
```

```{python}
print(smith_waterman("asj", "asd"))


```



```{python}
def build_distance_matrix(sequences: Dict[str, str]) -> Tuple[np.ndarray, List[str]]:
    """Builds distance matrix using Smith-Waterman scores.

    Args:
        sequences (Dict[str, str]): Dictionary of HIV RT sequences

    Returns:
        Tuple[np.ndarray, List[str]]: Distance matrix and list of sequence IDs

    Examples:
        >>> seqs = read_fasta("lafayette_SARS_RT.fasta")
        >>> mat, ids = build_distance_matrix(seqs)
        >>> mat[0:3, 0:3]  # Show 3x3 slice of distance matrix
        array([[0.000, 0.004, 0.012],
              [0.004, 0.000, 0.012],
              [0.012, 0.012, 0.000]])
        >>> len(ids)  # Number of sequences
        19
    """
    
    # establish list for sequence IDs by using .keys() and converting that to list
    seq_ids = list(sequences.keys())
    
    print()
    # establish empty matrix of len(sequences.keys()) x len(sequences.keys())
    n = len(seq_ids)
    dist_mat = np.empty(shape=(n,n), dtype = float)

    # loop through each sequence ID, filling out the matrix at i,j and j,i because they will be the same score
    for i, acc1 in enumerate(seq_ids):
      for j, acc2 in enumerate(seq_ids):
        # Hamming?
        total_len = max((len(sequences[acc1]), len(sequences[acc2])))
        dist_mat[i,j] =  total_len - td.smith_waterman(sequences[acc1], sequences[acc2]) 
        dist_mat[j,i] = dist_mat[i,j]
        if i == j:
          break
    return (dist_mat, seq_ids)
```

```{python}
sequences = {"1234": "ASDF", "2345": "ASDG", "3456": "ADDF", "4567": "AAAA"}
dis_mat, seq_ids = build_distance_matrix(sequences)
print(dis_mat)
print(seq_ids)
```

```{python}
def get_min_distance(matrix):
    ''' Function to find the smallest value off-daigonal in the distance
    matrix provided. This is used in the UPGMA algorithm.
    
    Args: 
        matrix (2D numpy array): a distance matrix

    Returns:
        min (float): The smallest distance in the matrix
        pos (tuple): The x and y position of the smallest distance
    
    '''
    
    minimum = np.min(matrix)
    min_pos = np.unravel_index(np.argmin(matrix), matrix.shape)
    print(min_pos)
    return minimum, min_pos
    
```

```{python}
def neighbor_joining(
    distance_matrix: np.ndarray,
    labels: List[str]
) -> str:
    """Implements Neighbor-Joining algorithm for phylogenetic tree construction.

    Args:
        distance_matrix (np.ndarray): Distance matrix from Smith-Waterman scores
        labels (List[str]): Sequence identifiers

    Returns:
        str: Newick format tree string

    Examples:
        >>> seqs = read_fasta("lafayette_SARS_RT.fasta")
        >>> mat, ids = build_distance_matrix(seqs)
        >>> tree = neighbor_joining(mat, ids)
        >>> tree.startswith("((DM1:0.002,DM2:0.002)")  # Start of Newick string
        True
        >>> tree.count(",")  # Number of separators in tree
        18
    """
    
    #from distance matrix, calculate total distances of each sequence
    total_distance = distance_matrix.sum(axis = 0)
    print(total_distance)
    
    #make Q matrix based off of neighbor joining equation D*ij = (n-2) * Dij - TotalDistance(i) - TotalDistance(j)
    n = len(labels)
    q_matrix = np.empty(shape=(n,n), dtype = float)
    for i, row in enumerate(distance_matrix):
      for j, value in enumerate(row):
        q_matrix[i,j] = (n - 2) * value - total_distance[i] - total_distance[j]
        q_matrix[j,i] = q_matrix[i,j]
        if i == j:
          break
    print(distance_matrix)
    print(q_matrix)
    #find min value and find out which two sequences share it (i.e. both [i,j] and [j,i] contain the min)
    min_val, min_pos = get_min_distance(q_matrix)
    
    #find difference of i and j with equation deltaij = (TotalDistance(i) - TotalDistance(j))/(n-2)
    i = min_pos[0]
    j = min_pos[1]
    
    total_disti = total_distance[i]
    total_distj = total_distance[j]
    delta = (total_disti - total_distj) / (n-2)
    
    limb_lengthi = (distance_matrix[i] + delta) / 2
    limb_lengthj = (distance_matrix[j] - delta) / 2
    
    
```


```{python}
sequences = {"1234": "ASDF", "2345": "ASDG", "3456": "ADDF", "4567": "AAAA"}
dis_mat, seq_ids = build_distance_matrix(sequences)
tree = neighbor_joining(dis_mat, seq_ids)
```


```{python}
def plot_tree(newick_tree: str) -> None:
    """Plots phylogenetic tree using ete3.

    Args:
        newick_tree (str): Tree in Newick format
    """
    tree = ete3.Tree(newick_tree)
    ts = ete3.TreeStyle()
    ts.show_leaf_name = True
    ts.mode = "c"  # circular style
    return tree.render("%%inline", tree_style=ts)
```

```{python}
if __name__ == "__main__":
    # Read HIV RT sequences
    sequences = {"1234": "ASDLKJFLS", "2345": "SLDFKJIED", "3456": "IKEPCLDGT", "4567": "PEOFKLCJU"}
    #read_fasta("lafayette_SARS_RT.fasta")
    
    # Build distance matrix using Smith-Waterman
    dist_matrix, seq_ids = build_distance_matrix(sequences)
    
    # Generate unrooted tree using Neighbor-Joining
    tree = neighbor_joining(dist_matrix, seq_ids)
    
    # Plot tree
    plot_tree(tree)
```

